<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 小说工具箱 (V15.4 按钮修复版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        /* 样式代码保持 V12.0 一致 */
        :root {
            --body-bg: #f4f6f9; --container-bg: #ffffff; --log-bg: #fdfdfd;
            --border-color: #dee2e6; --text-color: #212529; --button-bg: #007bff;
            --button-text: #ffffff; --button-hover-bg: #0056b3; --button-disabled-bg: #ced4da;
            --success-color: #28a745; --error-color: #dc3545; --info-color: #17a2b8;
            --task-button-bg: #6c757d; --task-button-hover-bg: #5a6268;
            --setting-button-bg: #20c997; 
            --setting-button-hover-bg: #1aa67f;
        }
        body { font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif; background-color:var(--body-bg); margin:0; padding:20px; display:flex; justify-content:center; align-items:flex-start; min-height:100vh; }
        #app-container { width:100%; max-width:900px; background-color:var(--container-bg); border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,.08); display:flex; flex-direction:column; overflow:hidden; }
        .header { padding:20px; border-bottom:1px solid var(--border-color); background-color:#fff; display:flex; justify-content:space-between; align-items:center; }
        .header h2 { margin:0; font-size: 1.5em; }
        .task-management { display:flex; gap:10px; }
        .task-button { padding:8px 15px; border:none; background-color:var(--task-button-bg); color:white; border-radius:6px; cursor:pointer; font-size:.9em; transition:background-color .2s; }
        .task-button:hover { background-color:var(--task-button-hover-bg); }
        .mode-selector { display:flex; border-bottom:1px solid var(--border-color); background-color: #f8f9fa;}
        .mode-button { flex:1; padding:15px; background-color:transparent; border:none; cursor:pointer; font-size:1.1em; font-weight:600; color:#495057; border-bottom:3px solid transparent; transition:all .2s; }
        .mode-button.active { color:var(--button-bg); border-bottom-color:var(--button-bg); background-color:#fff; }
        .control-panel { padding:20px; }
        .control-grid { display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:20px; }
        .input-group { display:flex; flex-direction:column; }
        .input-group label { margin-bottom:8px; font-weight:600; color:#495057; }
        .input-group input, .input-group select, .input-group textarea { width:100%; padding:10px; border:1px solid var(--border-color); border-radius:6px; font-size:1em; box-sizing:border-box; background-color:#fff; }
        .api-key-area { display:flex; align-items:flex-end; gap:10px; margin-bottom:20px; }
        #api-key-input { flex-grow:1; }
        #verify-key-button { padding:10px 15px; border:none; background-color:var(--info-color); color:white; border-radius:6px; cursor:pointer; white-space:nowrap; }
        #key-status { margin-left:10px; font-weight:bold; padding-top:28px; }
        .status-unverified { color:#6c757d; } .status-verifying { color:var(--info-color); }
        .status-verified { color:var(--success-color); } .status-invalid { color:var(--error-color); }
        .fieldset-disabled { opacity:.5; pointer-events:none; }
        .start-button { width:100%; padding:12px 20px; border:none; background-color:var(--button-bg); color:var(--button-text); border-radius:8px; cursor:pointer; font-size:1.1em; font-weight:bold; transition:background-color .2s; margin-top: 20px; }
        .start-button:hover { background-color:var(--button-hover-bg); }
        .start-button:disabled { background-color:var(--button-disabled-bg); cursor:not-allowed; }
        #generate-setting-button { background-color: var(--setting-button-bg); }
        #generate-setting-button:hover { background-color: var(--setting-button-hover-bg); }
        #log-window { height:350px; background-color:var(--log-bg); border:1px solid var(--border-color); border-radius:8px; padding:15px; overflow-y:auto; font-family:"Courier New",Courier,monospace; font-size:.9em; line-height:1.6; margin:0 20px 20px 20px; white-space:pre-wrap; }
        .log-entry { margin-bottom:8px; }
        .log-info { color:var(--info-color); } .log-success { color:var(--success-color); font-weight:bold; }
        .log-error { color:var(--error-color); font-weight:bold; }
        .toggle-label { display:flex; align-items:center; gap:8px; font-weight:normal; }
        .autosave-panel { border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-top: 20px; background-color: #f8f9fa; }
        .autosave-panel fieldset { border: none; padding: 0; margin: 0; }
        .autosave-panel legend { font-weight: 600; padding: 0; margin-bottom: 10px; }
        .autosave-options { display: flex; align-items: center; gap: 15px; }
        .autosave-options input[type="number"] { width: 100px; }
    </style>
</head>
<body>

<div id="app-container">
    <div class="header">
        <h2>AI 小说工具箱 (V15.4 按钮修复版)</h2>
        <div id="task-management-area" class="task-management">
            <button id="save-task-button" class="task-button">保存任务</button>
            <input type="file" id="load-task-input" accept=".json" style="display: none;">
            <button id="load-task-button" class="task-button">加载任务</button>
        </div>
    </div>
    <div class="mode-selector">
        <button id="mode-new-book" class="mode-button active">新书创建</button>
    </div>
    <div class="control-panel">
        
        <div id="panel-ai" class="panel-content active">
             <div class="api-key-area">
                <div class="input-group" style="flex-grow: 1;"><label for="api-key-input">1. DeepSeek API Key</label><input type="password" id="api-key-input" placeholder="请粘贴您的 DeepSeek API Key"></div>
                <button id="verify-key-button">验证并保存 Key</button>
                <div id="key-status" class="status-unverified">未验证</div>
            </div>
            
            <fieldset id="main-controls" disabled>
                
                <div class="control-grid">
                    <div class="input-group">
                        <label for="total-word-count-input">2.1 全本预计总字数 (用于计算卷数)</label>
                        <input type="number" id="total-word-count-input" min="100000" step="100000" value="1050000"> 
                    </div>
                    <div class="input-group">
                        <label for="target-word-count">2.2 单章目标字数 (用于估算章节数)</label>
                        <input type="number" id="target-word-count" min="0" step="100" value="2500">
                    </div>
                </div>
                <div class="input-group" style="margin-bottom: 20px;">
                    <label>2.3 预计章节数 / 卷数 (自动计算)</label>
                    <input type="text" id="estimated-chapters-and-volumes" readonly style="background-color: #e9ecef; color: #495057;">
                </div>

                <div class="control-grid">
                    <div class="input-group"><label>3. AI 模型</label><select id="model-select"><option value="deepseek-chat">deepseek-chat</option><option value="deepseek-coder">deepseek-coder</option></select></div>
                    <div class="input-group" style="justify-content: flex-end;"><label class="toggle-label" for="stream-toggle"><input type="checkbox" id="stream-toggle" checked> 启用思考模式</label></div>
                </div>

                <div class="input-group" style="margin-bottom: 20px;"><label for="creative-inspiration-input">4. 核心创意灵感 (小说主旨、核心冲突、主角目标等)</label><textarea id="creative-inspiration-input" rows="8" placeholder="例如：一个被废的皇子，意外获得一枚神秘戒指，内含一个古代炼丹师的残魂。他决定踏上复仇之路，同时寻找戒指的真正秘密..."></textarea></div>

                <div id="panel-creation-wrapper">
                    
                    <div class="input-group" style="margin-bottom: 20px;"><label>5. 设置大纲/风格提示词</label><textarea id="outline-prompt-input" rows="5">你是一位深谙网文写作精髓的小说家。你的任务是根据章节提示，创作出符合**番茄小说节奏**的章节内容。请保持叙事节奏**紧凑、快速**，多使用短句、直叙，着重描写主角的**内心挣扎**和**高光时刻**，确保画面感和情绪渲染到位。**正文文笔必须干净利落，禁止水字数、禁止啰嗦铺垫。**
                    
【状态追踪要求】：在正文内容全部结束后，必须且仅输出一个状态追踪 JSON 区块。
起始标记：//---STATUS-TRACKING-START---//
结束标记：//---STATUS-TRACKING-END---//
JSON 格式：你必须输出一个**顶层 JSON 对象**，该对象包含**分类键**，如 "Protagonist_Status" 或 "Key_Items"，每个分类键下的值是该分类中发生变化的键值对。如果某一分类中无变化，则在顶层对象中**省略**该分类键。如果所有分类都无变化，输出空 JSON 对象：{}。
</textarea></div>
                    
                    <div class="input-group" style="margin-bottom: 20px;">
                        <label>6. 选择开始生成/续写的卷数 (设定生成后可见)</label>
                        <select id="start-volume-select" disabled>
                            <option value="0">请先生成设定</option>
                        </select>
                    </div>
                </div>

                <div id="setting-review-panel" style="display:none; border:1px solid #ffc107; background-color:#fff3cd; padding:15px; border-radius:8px; margin-top:20px;">
                    <h3 style="margin-top:0; color:#856404;">✓ 设定生成完成，请审核并修改</h3>
                    
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label for="review-title-input">作品名 (文件命名依据)</label>
                        <input type="text" id="review-title-input" disabled style="background-color: #e9ecef;"/>
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label for="review-protagonist-input">主角姓名</label>
                        <input type="text" id="review-protagonist-input"/>
                    </div>
                    <div class="input-group" style="margin-bottom: 10px;">
                        <label for="review-synopsis-input">简介/大纲总结</label>
                        <textarea id="review-synopsis-input" rows="3"></textarea>
                    </div>
                    
                    <div class="input-group" style="margin-bottom: 15px;">
                        <label for="review-kb-input">知识库内容 (建议仅做小调整)</label>
                        <textarea id="review-kb-input" rows="10"></textarea>
                    </div>

                    <button id="confirm-setting-button" class="start-button" style="background-color: #28a45; margin-top: 0;">确认修改并开始生成正文</button>
                </div>
                <div class="autosave-panel">
                    <fieldset>
                        <legend><label class="toggle-label"><input type="checkbox" id="autosave-enable">启用自动保存/暂停</label></legend>
                        <div id="autosave-options" class="fieldset-disabled">
                            <label class="toggle-label"><input type="radio" name="autosave-mode" value="chapter" checked> 按章节数 (本次新生成)</label>
                            <input type="number" id="autosave-chapter-count" min="1" value="10">
                            <label class="toggle-label"><input type="radio" name="autosave-mode" value="word"> 按字数 (本次新生成)</label>
                            <input type="number" id="autosave-word-count" min="1000" step="1000" value="20000">
                        </div>
                    </fieldset>
                </div>

                <button id="generate-setting-button" class="start-button" style="background-color: var(--setting-button-bg); margin-top: 20px;">第 1 步：生成小说设定/大纲/知识库</button>
                <button id="start-button" class="start-button" disabled style="background-color: var(--button-bg); margin-top: 10px;">第 2 步：开始生成小说正文</button>
            </fieldset>
        </div>
    </div>
    
    <div id="monitoring-panel" style="padding: 15px 20px 5px; background-color: #e9ecef; border-top: 1px solid var(--border-color); display: flex; flex-direction: column; gap: 8px;">
        <div style="font-weight: 600; color: #495057;">任务实时监控</div>
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="width: 48%;">
                <label style="font-size: 0.85em;">总字数进度 (本次任务)</label>
                <div id="word-count-display" style="font-size: 1.2em; font-weight: bold; color: var(--success-color);">0 字</div>
            </div>
            <div style="width: 48%;">
                <label style="font-size: 0.85em;">章节进度</label>
                <div id="chapter-progress-text" style="font-size: 1.2em; font-weight: bold; color: var(--info-color);">0 / 0 章</div>
            </div>
        </div>
        <progress id="main-progress-bar" value="0" max="100" style="width: 100%; height: 8px; margin-bottom: 10px;"></progress>
        <div id="token-summary" style="font-size: 0.8em; color: #6c757d; display: none;"></div>
    </div>
    <div id="log-window">欢迎使用 AI 小说工具箱 V15.4 按钮修复版！</div>
</div>

<script>
    // --- V15.4 FULL SCRIPT (Button Fix and Calculation) ---
    const TRACKING_START = '//---STATUS-TRACKING-START---//';
    const TRACKING_END = '//---STATUS-TRACKING-END---//';
    
    // V15.1: 统一使用 DeepSeek API URL
    const DEEPSEEK_API_URL = 'https://api.deepseek.com/chat/completions'; 
    const QWEN_API_URL = 'https://api.deepseek.com/chat/completions'; // Placeholder - will use DEEPSEEK_API_URL

    // --- V13.0 知识库结构：强化通用知识库 (Global KB) 的强制性 ---
    const KB_STRUCTURE = {
        MANDATORY: [
            "Cultivation_System", 
            "World_View",         
            "History_Lore",       
            "Protagonist_Status"  
        ],
        ALL: [
            "Protagonist_Status", 
            "Cultivation_System",
            "Key_Items", 
            "World_View", 
            "Main_Antagonists", 
            "Locations_Map",
            "Faction_Politics", 
            "Skill_Spells",     
            "History_Lore"      
        ]
    };
    // ----------------------------------------

    const elements = {
        apiKeyInput: document.getElementById('api-key-input'), verifyKeyButton: document.getElementById('verify-key-button'), keyStatus: document.getElementById('key-status'), mainControls: document.getElementById('main-controls'), 
        workTitleInput: document.getElementById('work-title-input'), 
        modelSelect: document.getElementById('model-select'), streamToggle: document.getElementById('stream-toggle'), startButton: document.getElementById('start-button'), logWindow: document.getElementById('log-window'), 
        saveTaskButton: document.getElementById('save-task-button'), loadTaskInput: document.getElementById('load-task-input'), loadTaskButton: document.getElementById('load-task-button'), taskManagementArea: document.getElementById('task-management-area'),
        
        totalWordCountInput: document.getElementById('total-word-count-input'),
        estimatedChaptersAndVolumes: document.getElementById('estimated-chapters-and-volumes'),
        creativeInspirationInput: document.getElementById('creative-inspiration-input'),
        generateSettingButton: document.getElementById('generate-setting-button'), 
        startVolumeSelect: document.getElementById('start-volume-select'),

        outlinePromptInput: document.getElementById('outline-prompt-input'), 
        targetWordCount: document.getElementById('target-word-count'), 
        
        autosaveEnable: document.getElementById('autosave-enable'), autosaveOptions: document.getElementById('autosave-options'), autosaveChapterCount: document.getElementById('autosave-chapter-count'), autosaveWordCount: document.getElementById('autosave-word-count'),
        
        // V13.2 审核区域元素引用
        reviewPanel: document.getElementById('setting-review-panel'),
        reviewTitleInput: document.getElementById('review-title-input'),
        reviewProtagonistInput: document.getElementById('review-protagonist-input'),
        reviewSynopsisInput: document.getElementById('review-synopsis-input'),
        reviewKBInput: document.getElementById('review-kb-input'),
        confirmSettingButton: document.getElementById('confirm-setting-button'),
        
        // V15.1 移除 Formatting Model 元素
        formatApiKeyInput: document.getElementById('format-api-key-input'), 
        formatModelSelect: document.getElementById('format-model-select'),
        verifyFormatKeyButton: document.getElementById('verify-format-key-button'), 
        formatKeyStatus: document.getElementById('format-key-status'),           
        
        // V13.7 监控区域元素引用
        wordCountDisplay: document.getElementById('word-count-display'),
        chapterProgressText: document.getElementById('chapter-progress-text'),
        mainProgressBar: document.getElementById('main-progress-bar'),
        tokenSummary: document.getElementById('token-summary'),
    };

    let AppState = { 
        mode: 'new-book', 
        totalWordCount: 1050000, // V15.3 默认值修正
        inspiration: '',
        volumes: [],
        fullOutline: '',
        knowledgeBase: '', 
        bookSettings: {
            titles: [], 
            synopsis: '', 
            protagonist: '主角姓名待定' 
        },
        currentRunningStatus: {},
        kbCache: {},
        tokenUsage: {
            total: 0,
            prompt: 0,
            completion: 0,
            estimatedCost: 0 
        }
    };

    // --- UTILITY FUNCTIONS ---
    function log(message, type = 'info') { const e = document.createElement('div'); e.textContent = `[${new Date().toLocaleTimeString()}] ${message}`; e.className = `log-entry log-${type}`; elements.logWindow.appendChild(e); elements.logWindow.scrollTop = elements.logWindow.scrollHeight; }
    
    // V15.1: 统一的 Main API Call (DeepSeek Only)
    async function callMainAPI(messages, model = elements.modelSelect.value, useStream = false) {
        const apiKey = elements.apiKeyInput.value.trim();
        const url = DEEPSEEK_API_URL; 

        const response = await fetch(url, { 
            method: 'POST', 
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, 
            body: JSON.stringify({ 
                model, 
                messages, 
                stream: useStream, 
                temperature: 0.8, 
                max_tokens: 4096 
            }) 
        });
        if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.message || `API Error status: ${response.status}`); }
        
        if (useStream) {
             return handleStreamResponse(response); 
        }
        
        const data = await response.json();
        const usage = data.usage;
        const content = data.choices[0].message.content; 
        
        if (usage) {
            AppState.tokenUsage.total += usage.total_tokens || 0;
            AppState.tokenUsage.prompt += usage.prompt_tokens || 0;
            AppState.tokenUsage.completion += usage.completion_tokens || 0;
        }
        return content;
    }
    
    // V15.1: Formatting Task uses Main API
    async function callFormattingAPI(messages, model = elements.modelSelect.value) {
        return callMainAPI(messages, model, false);
    }
    
    async function handleStreamResponse(response) {
        const reader = response.body.getReader(), decoder = new TextDecoder(); 
        let fullContent = '', div = document.createElement('div'); 
        div.className = 'log-content'; 
        elements.logWindow.appendChild(div); 
        while (true) { 
            const { done, value } = await reader.read(); 
            if (done) break; 
            const chunk = decoder.decode(value); 
            for (const line of chunk.split('\n\n')) { 
                if (line.startsWith('data: ')) { 
                    const ds = line.substring(6); 
                    if (ds.trim() === '[DONE]') continue; 
                    try { 
                        const d = JSON.parse(ds), c = d.choices[0]?.delta?.content; 
                        if (c) { 
                            fullContent += c; 
                            div.textContent += c; 
                            elements.logWindow.scrollTop = elements.logWindow.scrollHeight; 
                        } 
                    } catch (e) { /* silent fail for malformed stream data */ } 
                } 
            } 
        } 
        return fullContent; 
    }

    function saveAsTxt(content, filename) { 
        if (!content) { log(`没有可保存的内容：${filename}`, 'error'); return; }
        const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); 
        const a = document.createElement('a'), url = URL.createObjectURL(blob); 
        a.href = url; 
        document.body.appendChild(a); 
        a.download = filename;
        a.click(); 
        document.body.removeChild(a); 
        URL.revokeObjectURL(url); 
        log(`文件已触发下载: ${filename}`, 'success'); 
    }

    // V12.2: 递归合并状态对象 (保持不变)
    function mergeStatus(target, source) {
        target = target || {};
        source = source || {};

        for (const key in source) {
            if (source.hasOwnProperty(key)) {
                const sourceValue = source[key];
                const targetValue = target[key];

                if (typeof sourceValue === 'object' && sourceValue !== null && !Array.isArray(sourceValue) &&
                    (typeof targetValue === 'object' || typeof targetValue === 'undefined')) {
                    
                    target[key] = mergeStatus(targetValue, sourceValue);
                } else {
                    target[key] = sourceValue;
                }
            }
        }
        return target;
    }
    
    // V15.2 修正：确保使用 Math.ceil 进行精确计算
    function updateEstimate() {
        const totalWords = parseInt(elements.totalWordCountInput.value) || 0;
        const singleChapterWords = parseInt(elements.targetWordCount.value) || 0; 
        AppState.totalWordCount = totalWords;

        if (totalWords > 0 && singleChapterWords > 0) {
            // 核心修正：使用 Math.ceil 确保精确计算
            const estimatedChapters = Math.ceil(totalWords / singleChapterWords);
            const estimatedVolumes = Math.ceil(estimatedChapters / 60); 
            
            elements.estimatedChaptersAndVolumes.value = 
                `预计 ${estimatedChapters} 章 / 约 ${estimatedVolumes} 卷`;
        } else {
            elements.estimatedChaptersAndVolumes.value = '请填写有效的总字数和单章字数';
        }
    }

    function updateVolumeSelect() {
        const select = elements.startVolumeSelect;
        select.innerHTML = '';
        if (AppState.volumes.length === 0) {
            select.innerHTML = '<option value="0">请先生成设定</option>';
            select.disabled = true;
            return;
        }
        select.disabled = false;
        AppState.volumes.forEach((volume, index) => {
            let completed = volume.chapterPrompts.filter(c => c.generatedContent).length;
            let total = volume.chapterPrompts.length;
            let optionText = `第 ${index + 1} 卷：${volume.title} (${completed}/${total} 章完成)`;
            const option = document.createElement('option');
            option.value = index;
            option.textContent = optionText;
            select.appendChild(option);
        });
        
        const firstUncompletedVolumeIndex = AppState.volumes.findIndex(v => v.chapterPrompts.some(c => !c.generatedContent));
        if (firstUncompletedVolumeIndex !== -1) {
            select.value = firstUncompletedVolumeIndex;
        } else if (AppState.volumes.length > 0) {
            select.value = AppState.volumes.length - 1;
        }
        elements.startButton.disabled = false;
    }

    // V13.2: 确认修改并开始生成正文
    function confirmSetting() {
        const finalTitle = elements.reviewTitleInput.value.trim();
        const finalProtagonist = elements.reviewProtagonistInput.value.trim();
        const finalSynopsis = elements.reviewSynopsisInput.value.trim();
        const finalKB = elements.reviewKBInput.value.trim();

        if (!finalTitle || !finalProtagonist) {
            alert('作品名和主角名不能为空！');
            return;
        }

        // 2. 更新 AppState 的核心数据
        elements.workTitleInput.value = finalTitle; // 更新文件命名依据
        AppState.bookSettings.protagonist = finalProtagonist;
        AppState.bookSettings.synopsis = finalSynopsis;
        AppState.knowledgeBase = finalKB;

        // V13.3: 清空缓存，因为知识库内容可能已被修改
        AppState.kbCache = {};

        // 3. 隐藏审核面板，激活下一阶段的生成按钮
        elements.reviewPanel.style.display = 'none';
        elements.generateSettingButton.textContent = '第 1 步：重新生成设定 (如果需要)';
        elements.startButton.textContent = '第 2 步：开始生成小说正文';
        
        // 4. 由于知识库可能被修改，重新更新卷选择器状态
        updateVolumeSelect(); 
        
        log(`✓ 设定已确认。作品名: ${finalTitle}。点击“第 2 步”按钮开始生成正文。`, 'success');
    }
    
    // --- STEP 1: GENERATE SETTINGS (V15.1 Single Model) ---
    async function generateFullSetting() {
        if (elements.keyStatus.textContent !== '✓ 已验证') { alert('请先验证您的主力 API Key！'); return; }
        
        // V15.1 Formatting Key 检查移除 (这两行代码因HTML元素已删除而注释掉)
        // elements.formatKeyStatus.className = 'status-unverified';
        // elements.formatKeyStatus.textContent = '未使用';

        const inspiration = elements.creativeInspirationInput.value.trim();
        if (!inspiration) { alert('请填写核心创意灵感！'); return; }

        elements.generateSettingButton.disabled = true;
        elements.startButton.disabled = true;
        elements.reviewPanel.style.display = 'none'; // 隐藏审核面板
        elements.logWindow.innerHTML = '';
        log('--- 启动完整设定生成流程 (共 4 阶段) ---', 'info');

        const apiKey = elements.apiKeyInput.value.trim();
        const model = elements.modelSelect.value;
        const totalWords = AppState.totalWordCount;
        
        // V13.4/V13.5 Prompt 优化: 阶段 1
        const singleChapterWords = parseInt(elements.targetWordCount.value) || 3000;
        const outlineSystem = "你是一位顶级的网文策划编辑，熟知番茄小说爆款的黄金法则。你的任务是基于我提供的【核心创意灵感】，设计一份**商业性极强**、**节奏快**、**爽点密集**的小说大纲。**【前三章要求】**：必须立即爆发核心矛盾或爽点，快速确立主角人设和金手指，保证**高点击率和高留存**。大纲必须突出主角的**不可或缺性**、明确的**升级路线**和**核心冲突**，确保读者代入感强，且每隔 10-15 章有一个小高潮。";
        const inspirationPrompt = `【核心创意灵感】：${inspiration}\n【预计总字数】：${totalWords}字。`;

        try {
            // 阶段 1: 生成详细大纲 (使用主力模型)
            log('正在生成详细大纲...', 'info');
            const outlineUser = `${inspirationPrompt} 请直接输出大纲正文。`;
            AppState.fullOutline = await callMainAPI([{ role: 'system', content: outlineSystem }, { role: 'user', content: outlineUser }]);
            log('✓ 阶段 1/4：详细大纲生成完毕。', 'success');

            // 阶段 2: 生成知识库 (使用主力模型进行格式化)
            log('正在分块生成小说知识库 (使用主力模型)...', 'info');

            const kbCategories = KB_STRUCTURE.ALL; 
            let fullKbContent = "## AI 生成的小说知识库\n\n";

            // V13.4 Prompt 优化: 阶段 2
            const kbSystemBase = `你是一位严谨的设定维护工程师。基于提供的【详细大纲】，你的任务是生成**指定模块**的知识库内容。内容必须**极其详细**、**精准**，并使用表格和简洁的 Markdown 列表突出**名称、等级、效果**等关键数据，确保这些设定具备**可量化、可追踪**的特性。这是连贯性的硬性保证。

【内容格式要求】：
1. **列表**：所有描述性、大纲性的内容必须使用 Markdown 无序列表 (*) 组织。
2. **表格**：所有需要精确定义和追踪的关键属性、名称、等级、效果等，必须使用 Markdown 表格 (\`| \`) 展示。

请严格遵守以上格式要求。`;
            const kbTemplate = `【详细大纲】：\n---\n${AppState.fullOutline}\n-\n`;

            for (const category of kbCategories) {
                log(`...正在生成模块: 【${category}】`, 'info');
                
                const kbUser = `${kbTemplate}
请现在只生成**【${category}】**模块的内容。`;

                const categoryContent = await callMainAPI([{ role: 'system', content: kbSystemBase }, { role: 'user', content: kbUser }], model, false);
                
                fullKbContent += `### ${category}\n\n${categoryContent.trim()}\n\n`;
            }

            AppState.knowledgeBase = fullKbContent;
            log('✓ 阶段 2/4：小说知识库分块生成完毕。', 'success');


            // 阶段 3: 生成基础设定 (使用主力模型)
            log('正在生成书名、简介和主角姓名 (商业优化/纯文本解析)...', 'info');
            
            // V13.5 商业化 System Prompt
            const settingsSystem = `你是一位顶级的网文营销策划，深知如何通过书名和简介吸引读者。基于提供的【详细大纲】和【知识库】，请提供3个书名方案、1个小说简介、以及主角姓名。

【书名要求】（每个书名都要具备）：
1. **要素明确**：书名必须包含主角金手指、身份、或核心设定中的1-2个关键词。
2. **高能冲突**：书名必须暗示故事的爽点、冲突或升级方向。
3. **字数精炼**：书名总字数建议控制在4到8个字。

【简介要求】（必须采用三段式结构）：
1. **背景引入**：快速抛出主角的悲惨/废柴人设和获得金手指或机缘的背景。
2. **核心冲突**：设置一个当前面临的巨大矛盾或高潮，吸引读者。
3. **爽点收束**：用一句高能的承诺或主角霸气的宣言作结，暗示主角的崛起。

要求严格按照以下纯文本格式输出，不得包含任何其他内容或解释：
书名1：[书名]
书名2：[书名]
书名3：[书名]
简介：[简介内容]
主角姓名：[主角姓名]`;

            const settingsUser = `【详细大纲】：\n${AppState.fullOutline}\n【知识库】：\n${AppState.knowledgeBase}`;
            const settingsRaw = await callMainAPI([{ role: 'system', content: settingsSystem }, { role: 'user', content: settingsUser }], model, false);
            
            // V12.5: 使用 JS 代码解析纯文本
            try {
                const titles = settingsRaw.match(/书名\d：(.*)/g).map(line => line.split('：')[1].trim());
                const synopsisMatch = settingsRaw.match(/简介：(.*)/);
                const protagonistMatch = settingsRaw.match(/主角姓名：(.*)/);

                if (!synopsisMatch || !protagonistMatch || titles.length < 3) {
                    throw new Error('AI输出格式不完整，缺少书名、简介或主角姓名。');
                }

                const synopsis = synopsisMatch[1].trim();
                const protagonist = protagonistMatch[1].trim();
                
                AppState.bookSettings.titles = titles;
                AppState.bookSettings.synopsis = synopsis;
                AppState.bookSettings.protagonist = protagonist;
                
                elements.workTitleInput.value = titles[0] || 'AI生成作品'; 
                log(`✓ 阶段 3/4：基础设定生成完毕。主角: ${protagonist}。书名已设置为: ${elements.workTitleInput.value}`, 'success');
            } catch (e) {
                 log(`✗ 阶段 3/4：基础设定解析失败，请检查 AI 输出是否符合格式。错误: ${e.message}`, 'error');
                 log(`AI 原始输出：${settingsRaw.substring(0, 500)}...`, 'error');
                 AppState.bookSettings.protagonist = '主角姓名待定';
                 elements.workTitleInput.value = 'AI生成作品_错误';
            }
            
            // V15.2: 设定生成成功，立即保存任务和文件
            const title = elements.workTitleInput.value.trim() || '未命名小说';
            
            // 触发任务和文件下载 (保存设定)
            saveTask(true); 
            log(`★ 设定已保存为任务文件 ${title}_task.json，您可以随时加载并继续。`, 'info');

            // 阶段 4: 生成卷结构和章节细纲 (V14.2 迭代修复)
            log('正在生成分卷结构和章节细纲...', 'info');
            AppState.volumes = await generateVolumeStructure(AppState.fullOutline, AppState.totalWordCount, AppState.bookSettings.protagonist, apiKey, model);
            log(`✓ 阶段 4/4：已生成 ${AppState.volumes.length} 卷的结构和章节细纲。`, 'success');

            // V13.2 流程结束：进入人工审核阶段
            
            // 触发细纲文件下载 (已在 saveTask 中完成)
            // 绑定数据到审核面板
            elements.reviewTitleInput.value = title;
            elements.reviewProtagonistInput.value = AppState.bookSettings.protagonist;
            elements.reviewSynopsisInput.value = AppState.bookSettings.synopsis;
            elements.reviewKBInput.value = AppState.knowledgeBase;
            
            elements.reviewPanel.style.display = 'block'; // 显示审核面板
            elements.startButton.disabled = true; // 禁用原生成按钮
            
            log('--- 任务暂停：请在上方审核面板中检查并确认所有设定，然后点击“确认修改并开始生成正文” ---', 'success');

        } catch (error) {
            log(`✗ 设定生成任务因错误停止: ${error.message}`, 'error');
        } finally {
            elements.generateSettingButton.disabled = false;
        }
    }

    // V14.2: 卷结构生成函数 (迭代细纲生成)
    async function generateVolumeStructure(outline, totalWords, protagonist, apiKey, model) {
        const singleChapterWords = parseInt(elements.targetWordCount.value) || 3000;
        const estimatedChapters = Math.ceil(totalWords / singleChapterWords) || 60;
        const estimatedVolumes = Math.max(1, Math.ceil(estimatedChapters / 60)); 

        let volumes = [];
        let currentChapter = 1;

        log('正在通过 AI 确定分卷结构和每卷地图 (纯文本解析)...', 'info');
        
        const structureSystem = `你是一位小说结构专家。你的任务是根据【详细大纲】，将小说划分为合理的卷数，并为每卷设定核心地图。

【卷结构要求】：
1. **卷长控制**：每卷应保持在 60 章左右，并保证每章目标字数 (${singleChapterWords}字) 的总字数合理分配。
2. **地图密度**：每卷必须绑定 **1 到 2 个** 核心地图或背景（根据该卷的情节复杂度和密度决定）。
3. **输出格式**：要求严格按照以下纯文本格式输出，不得包含任何其他内容或解释：
【卷名】：[卷的名称]
【地图/背景】：[该卷的核心地图或多个地图的名称及简要描述]
[重复此格式直到所有卷完成]`;
        
        const structureUser = `【详细大纲】：\n${outline}\n【主角】：${protagonist}`;
        const structureRaw = await callMainAPI([{ role: 'system', content: structureSystem }, { role: 'user', content: structureUser }], model, false);
        
        try {
            const lines = structureRaw.split('\n');
            let currentVolume = null;

            lines.forEach(line => {
                if (line.startsWith('【卷名】：')) {
                    if (currentVolume) volumes.push(currentVolume);
                    const title = line.split('：')[1].trim();
                    currentVolume = { title: title, map: '待补充', chapterPrompts: [] };
                } else if (line.startsWith('【地图/背景】：') && currentVolume) {
                    currentVolume.map = line.split('：')[1].trim();
                }
            });
            if (currentVolume) volumes.push(currentVolume);

            if (volumes.length === 0) throw new Error('未能解析出任何卷结构，请检查AI输出。');

            while (volumes.length < estimatedVolumes) {
                volumes.push({ title: `卷${volumes.length + 1}：系统命名`, map: `地图${volumes.length + 1}的简要描述`, chapterPrompts: [] });
            }
            
        } catch (e) {
            log(`✗ 卷结构解析失败，使用默认卷名。错误: ${e.message}`, 'error');
            volumes = Array.from({ length: estimatedVolumes }, (_, i) => ({ title: `卷${i + 1}：默认卷`, map: `默认地图描述`, chapterPrompts: [] }));
        }

        let totalGeneratedChapters = 0;
        
        for (let i = 0; i < estimatedVolumes; i++) {
            let volume = volumes[i] || { title: `卷${i + 1}：系统命名`, map: `默认地图描述`, chapterPrompts: [] };
            if (!volumes[i]) volumes.push(volume); 

            let volumeChaptersGoal = 60;
            if (i === estimatedVolumes - 1) {
                 volumeChaptersGoal = estimatedChapters - totalGeneratedChapters;
                 if (volumeChaptersGoal <= 0) break;
            }

            log(`正在为 ${volume.title} 生成 ${volumeChaptersGoal} 个章节细纲 (迭代模式)...`, 'info');
            
            // V14.4 强化局部边界的约束
            const chapterSystemBase = `你是一位小说情节大师。你的任务是基于【大纲】和【当前卷的设定】，为接下来的章节生成细纲。
            
【边界约束——禁止剧透】：
1. **内容限制**：细纲内容**严格限制**在【详细大纲】中属于**当前卷**的情节范围。
2. **禁止超前**：**不得**在细纲中出现或暗示下一卷及更后续卷的核心冲突、人物结局或重大事件，以保证读者阅读节奏。

【创作重点强调】：* **如果是前三章**：细纲必须包含爆炸性冲突、紧凑的节奏和明确的金手指高光，以吸引读者。* **其他章节**：细纲需保证情节推进，避免水字数。
            要求输出一个严格的 JSON 数组，每个元素包含\`title\`和\`prompt\`字段。`;

            let currentVolumeChapters = 0;
            let currentChapterList = [];
            let maxAttempts = 3; 

            // V14.2 核心：使用 while 循环确保章节数量达标
            while (currentVolumeChapters < volumeChaptersGoal && maxAttempts > 0) {
                const requestBatchSize = Math.min(20, volumeChaptersGoal - currentVolumeChapters); 
                
                if (requestBatchSize <= 0) break;

                const chapterUser = `【详细大纲】：\n${outline}\n【当前卷设定】：${volume.map}\n【从第 ${currentChapter} 章开始】。请生成**${requestBatchSize}**个章节细纲。`;
                
                try {
                    // V15.1: 细纲生成使用 Main API
                    const chapterRaw = await callMainAPI([{ role: 'system', content: chapterSystemBase }, { role: 'user', content: chapterUser }], model, false);
                    
                    let newPrompts = [];
                    try {
                         newPrompts = JSON.parse(chapterRaw.replace(/```json|```/g, '').trim());
                    } catch (e) {
                        log(`✗ JSON 解析失败 (${maxAttempts-1} attempts left)，AI 返回数据格式错误，尝试重新生成...`, 'error');
                        maxAttempts--;
                        if (maxAttempts <= 0) throw new Error("细纲生成多次失败，请检查大纲或网络。");
                        continue; 
                    }
                    
                    if (newPrompts.length === 0) {
                        log('AI 返回章节列表为空，认定细纲生成完毕或大纲已耗尽。', 'info');
                        break;
                    }
                    
                    currentChapterList.push(...newPrompts);
                    currentVolumeChapters += newPrompts.length;
                    currentChapter += newPrompts.length;
                    log(`...已生成 ${newPrompts.length} 章。当前卷累计: ${currentVolumeChapters}/${volumeChaptersGoal} 章。`, 'info');
                    maxAttempts = 3; // 成功后重置尝试次数

                } catch (error) {
                    log(`✗ 迭代生成细纲时 API 错误: ${error.message}。当前卷生成中断。`, 'error');
                    throw new Error(`细纲生成 API 失败: ${error.message}`);
                }
            }

            volume.chapterPrompts = currentChapterList.map(c => ({...c, generatedContent: null, statusChange: {}}));
            totalGeneratedChapters += currentVolumeChapters;
            log(`✓ ${volume.title} 最终生成了 ${currentVolumeChapters} 个章节细纲。`, 'success');
        }

        return volumes;
    }


    // --- STEP 2: GENERATE NOVEL CONTENT (V15.1 Main Model) ---
    function startGeneration() {
        if (elements.keyStatus.textContent !== '✓ 已验证') { alert('请先验证您的主力 API Key！'); return; }
        
        // V13.2 检查是否通过审核
        if(elements.reviewPanel.style.display !== 'none') {
             alert('请先点击“确认修改并开始生成正文”按钮完成设定审核！');
             return;
        }

        runTask(async () => {
            const apiKey = elements.apiKeyInput.value.trim(), outlinePrompt = elements.outlinePromptInput.value, selectedModel = elements.modelSelect.value, useStream = elements.streamToggle.checked;
            const startVolumeIndex = parseInt(elements.startVolumeSelect.value) || 0;
            const targetWordCount = parseInt(elements.targetWordCount.value) || 0;
            const chaptersGeneratedInSession = { count: 0, words: 0 };
            const isAutosaveEnabled = elements.autosaveEnable.checked;
            const autosaveMode = document.querySelector('input[name="autosave-mode"]:checked').value;
            const autosaveChapterTarget = parseInt(elements.autosaveChapterCount.value);
            const autosaveWordTarget = parseInt(elements.autosaveWordCount.value);

            let previousChapterContent = '';
            
            // 计算上次中断或本次开始的章节序号和总字数 (V13.7)
            let chapterCounter = 1;
            let initialTotalWords = 0;
            let chaptersCompletedAtStart = 0;
            let totalChaptersInList = 0;
            for(let i = 0; i < AppState.volumes.length; i++) {
                totalChaptersInList += AppState.volumes[i].chapterPrompts.length;
                for(let j = 0; j < AppState.volumes[i].chapterPrompts.length; j++) {
                    if (AppState.volumes[i].chapterPrompts[j].generatedContent) {
                        previousChapterContent = AppState.volumes[i].chapterPrompts[j].generatedContent;
                        initialTotalWords += previousChapterContent.length;
                        chaptersCompletedAtStart++;
                        chapterCounter++;
                    } else {
                         break;
                    }
                }
                if(i < AppState.volumes.length && AppState.volumes[i].chapterPrompts.some(c => !c.generatedContent)) break;
            }
            const wordCountGoal = initialTotalWords + autosaveWordTarget;
            
            // V13.7 监控初始化/更新
            elements.tokenSummary.style.display = 'none';
            elements.mainProgressBar.max = totalChaptersInList;
            elements.wordCountDisplay.textContent = `${initialTotalWords.toLocaleString()} 字`;
            elements.chapterProgressText.textContent = `${chaptersCompletedAtStart} / ${totalChaptersInList} 章`;
            elements.mainProgressBar.value = chaptersCompletedAtStart;


            for (let i = startVolumeIndex; i < AppState.volumes.length; i++) {
                const volume = AppState.volumes[i];
                const volumeMap = volume.map;
                
                for (let j = 0; j < volume.chapterPrompts.length; j++) {
                    const chapter = volume.chapterPrompts[j];
                    const chapterTitle = chapter.title;
                    const currentChapterNum = chapterCounter;
                    
                    if (chapter.generatedContent) { 
                        log(`跳过已生成的章节: 第${currentChapterNum}章 ${chapterTitle}`, 'info');
                        chapterCounter++; 
                        continue; 
                    }
                    if (!chapterTitle || !chapter.prompt) { 
                        log(`章节数据不完整，已跳过: 卷${i+1}，章${j+1}`, 'error'); 
                        chapterCounter++;
                        continue; 
                    }

                    log(`[卷 ${i+1}/${AppState.volumes.length}] 正在生成: 第${currentChapterNum}章 ${chapterTitle}...`, 'info');
                    
                    // --- 1.1 知识库局部提取 (V15.1: 统一使用 Main API) ---
                    log('...正在执行通用知识库强制拉取和地图知识库精炼...', 'info');

                    const fullKbText = AppState.knowledgeBase;
                    const mandatoryCategories = KB_STRUCTURE.MANDATORY; 
                    
                    // V13.3 缓存命中键：基于卷ID和章节细纲前50字符
                    const cacheKey = `v${i}_p${chapter.prompt.substring(0, 50)}`; 
                    let localKnowledge = "";
                    
                    // 1. 检查缓存命中
                    if (AppState.kbCache[cacheKey]) {
                        localKnowledge = AppState.kbCache[cacheKey];
                        log('...知识库缓存命中 (HIT)。跳过 AI 精炼。', 'info');
                    } else {
                        // 2. 未命中：执行 V12.6/V13.0 的筛选逻辑

                        let mandatoryKnowledge = "## 通用知识库 (代码强制提取)\n";
                        let remainingKnowledge = ""; 

                        // 使用正则表达式查找所有知识块
                        const categoryRegex = /###\s*(.*?)\s*\n\n([\s\S]*?)(?=(?:\n###|$))/g;
                        let match;
                        let allMatches = [];
                        categoryRegex.lastIndex = 0; 
                        while ((match = categoryRegex.exec(fullKbText)) !== null) {
                            allMatches.push(match);
                        }
                        
                        // A. 代码预筛选 (强制拉取通用知识库)
                        allMatches.forEach(match => {
                            const categoryName = match[1].trim();
                            const categoryContent = match[2].trim();
                            
                            if (mandatoryCategories.includes(categoryName)) {
                                mandatoryKnowledge += `### ${categoryName}\n${categoryContent}\n\n`;
                            } else {
                                remainingKnowledge += `### ${categoryName}\n${categoryContent}\n\n`;
                            }
                        });

                        // B. AI 精炼：筛选非必选模块 (地图知识库)
                        let optionalKnowledge = "";
                        if (remainingKnowledge.trim()) {
                            log('...AI 正在精炼可选地图知识模块 (MISS)...', 'info');
                            const knowledgeExtractionSystem = `你是一位专业的设定整理师。你的任务是根据【章节细纲】、【卷地图】和【当前状态】，从提供的【可选知识模块】中精确提取**本章创作必需**的设定信息。
要求：只输出提取出的相关设定文本，不需要任何解释或 JSON 包装。如果没有相关内容，请回复“无”。`;
                            const knowledgeExtractionUser = `【章节细纲】：${chapter.prompt}
【当前卷地图】：${volumeMap}
【当前累计状态】：${JSON.stringify(AppState.currentRunningStatus)}
---
【可选知识模块】：
${remainingKnowledge.trim()}`;

                            // V15.1 使用 Main API
                            optionalKnowledge = await callMainAPI([{ role: 'system', content: knowledgeExtractionSystem }, { role: 'user', content: knowledgeExtractionUser }], selectedModel, false); 
                        }
                        
                        // C. 合并最终局部知识库
                        if (optionalKnowledge.toLowerCase().includes("无") || optionalKnowledge.trim() === "") {
                            optionalKnowledge = "";
                        }

                        // 合并：通用知识库 + 地图知识库精炼结果
                        localKnowledge = mandatoryKnowledge.trim() + (optionalKnowledge.trim() ? ("\n\n## 地图知识库 (AI精炼结果)\n" + optionalKnowledge.trim()) : "");
                        log('...知识库筛选完毕。', 'success');

                        // 3. 存储到缓存
                        AppState.kbCache[cacheKey] = localKnowledge;
                        log('...局部知识库已存入缓存。', 'success');
                    }
                    
                    // 1.2 构造最终 Prompt (V13.4 最终优化)
                    let contextPrompt = '';
                    if (previousChapterContent) { 
                        const last500 = previousChapterContent.slice(-500); 
                        contextPrompt = `作为参考，这是上一章的结尾部分：\n---\n${last500}\n---\n\n`;
                    }
                    let statusPrompt = JSON.stringify(AppState.currentRunningStatus, null, 2);
                    let wordCountInstruction = targetWordCount > 0 ? `\n\n请确保本章内容篇幅充足，目标字数在 ${targetWordCount} 字左右。` : '';
                    
                    const systemPrompt = `你是一位深谙网文写作精髓的小说家。你的任务是根据章节提示，创作出符合**番茄小说节奏**的章节内容。请保持叙事节奏**紧凑、快速**，着重描写主角的**内心挣扎**和**高光时刻**。

【硬性设定原则】：
1. **定位与指引**：【局部设定/知识库】中的内容是创作的**基础和参考**，用于**确保连贯性**和**设定准确**，但**不应直接照搬**其中的文字或表格数值作为正文内容，以免影响文笔流畅度。
2. **状态强制性**：状态追踪中的【Life_Status】、【Status】等字段变化是不可逆的硬性设定，不得推翻。
3. **创作背景**：当前创作必须以【当前卷地图】为背景。

${elements.outlinePromptInput.value.trim()}\n\n【局部设定/知识库】：${localKnowledge}\n\n【当前卷地图】：${volumeMap}`;
                    
                    // V13.3 优化后的 User Prompt
                    const userPrompt = `${contextPrompt}
====================================
【连贯性核心数据 - 请必看】
主角姓名：${AppState.bookSettings.protagonist}
当前累计状态：${statusPrompt}
====================================

请严格遵循以下要求生成内容：
1. 直接开始撰写正文内容，不要在内容中重复或包含章节标题。
2. 本章的标题是【${chapterTitle}】，创作要求如下：\n\n${chapter.prompt}${wordCountInstruction}

====================================
【核心状态追踪任务】
请在创作前仔细检查【当前累计状态】。

在正文内容**全部结束**后，请严格按以下固定格式输出**知识库匹配的**状态变化 JSON 区块。
注意：JSON 必须包含分类键（如 "Protagonist_Status"），且只包含发生变化的条目。
${TRACKING_START}
[JSON对象]
${TRACKING_END}`;
                    
                    try {
                        // 2. 生成正文+状态 (V15.1 使用 Main API)
                        const messages = [{ role: 'system', content: systemPrompt }, { role: 'user', content: userPrompt }];
                        let fullResponse = await callMainAPI(messages, selectedModel, useStream);
                        
                        // 3. 解析正文和状态
                        let currentChapterContent = fullResponse;
                        let newStatusChange = {};

                        const [content, status] = parseContentAndStatus(fullResponse);
                        currentChapterContent = content;
                        newStatusChange = status;
                        
                        // 非流模式下需要手动将正文部分显示到 Log
                        if (!useStream) {
                            const div = document.createElement('div'); 
                            div.className = 'log-content'; 
                            div.textContent = currentChapterContent.trim(); 
                            elements.logWindow.appendChild(div);
                        }

                        log(`✓ 第${currentChapterNum}章 ${chapterTitle} - 正文生成完毕。`, 'success');
                        
                        // 4. 状态追踪更新
                        if (Object.keys(newStatusChange).length > 0) {
                            AppState.currentRunningStatus = mergeStatus(AppState.currentRunningStatus, newStatusChange);
                            log(`✓ 人物状态已更新: ${Object.keys(newStatusChange).join(', ')}`, 'info');
                        } else {
                            log('✓ 人物状态无不可逆变化。', 'info');
                        }
                        
                        // 5. 存储和推进
                        chapter.generatedContent = currentChapterContent.trim(); 
                        chapter.statusChange = newStatusChange;
                        previousChapterContent = currentChapterContent.trim();
                        chaptersGeneratedInSession.count++;
                        chaptersGeneratedInSession.words += chapter.generatedContent.length;
                        chapterCounter++;
                        
                        // V13.7 实时更新进度
                        const currentTotalWords = initialTotalWords + chaptersGeneratedInSession.words;
                        const currentTotalChapters = chaptersCompletedAtStart + chaptersGeneratedInSession.count;
                        
                        elements.wordCountDisplay.textContent = `${currentTotalWords.toLocaleString()} 字`;
                        elements.chapterProgressText.textContent = `${currentTotalChapters} / ${totalChaptersInList} 章`;
                        elements.mainProgressBar.value = currentTotalChapters;
                        
                        // 6. 自动保存检查
                        if (isAutosaveEnabled) {
                            const currentTotalWordCount = initialTotalWords + chaptersGeneratedInSession.words;
                            if ((autosaveMode === 'chapter' && chaptersGeneratedInSession.count >= autosaveChapterTarget) || (autosaveMode === 'word' && currentTotalWordCount >= wordCountGoal)) {
                                log(`已达到自动保存点。`, 'success');
                                saveTask(true); 
                                throw new Error('自动保存并暂停。');
                            }
                        }

                    } catch (error) {
                        log(`✗ 第${currentChapterNum}章 ${chapterTitle} - 任务中断: ${error.message}`, 'error');
                        const completedContent = buildFinalExportContent(); 
                        if (completedContent) { log('任务中断。自动保存已完成稿件...', 'info'); saveAsTxt(completedContent, `${elements.workTitleInput.value}_partial.txt`); }
                        throw new Error(`在章节 ${currentChapterNum} 处中断。`);
                    }
                }
            }
        });
    }

    // 重构 runTask 以适配两步流程 (V13.7 Token Summary)
    async function runTask(taskFunction) {
        if (elements.keyStatus.textContent !== '✓ 已验证') { alert('请先验证您的主力 API Key！'); return; }
        elements.startButton.disabled = true;
        
        try {
            // V13.7: 重置 Token 计数器
            AppState.tokenUsage = { total: 0, prompt: 0, completion: 0, estimatedCost: 0 };

            await taskFunction();
            log('所有章节处理完毕！正在准备下载...', 'success');
            saveTask(true);
        } catch (error) {
            log(`任务因错误或暂停而停止: ${error.message}`, 'error');
        } finally {
            // V13.7 Token 分析和显示
            const total = AppState.tokenUsage.total;
            const prompt = AppState.tokenUsage.prompt;
            const completion = AppState.tokenUsage.completion;
            
            // NOTE: 价格核算基于 DeepSeek/Qwen 的平均费率，仅供参考。
            const cost = ((prompt / 1000) * 0.0015 + (completion / 1000) * 0.003).toFixed(4);

            if (total > 0) {
                elements.tokenSummary.innerHTML = `
                    **Token 使用总结：** 总计 ${total.toLocaleString()} tokens (<span style="color:red;">预估成本约 $${cost} USD</span>)。
                    (Prompt: ${prompt.toLocaleString()} / Completion: ${completion.toLocaleString()})
                `;
                elements.tokenSummary.style.display = 'block';
                log(`TOKEN SUMMARY: 本次任务共消耗 ${total.toLocaleString()} tokens，预估成本 $${cost} USD。`, 'info');
            }

            const allCompleted = AppState.volumes.every(v => v.chapterPrompts.every(c => c.generatedContent));
            if (allCompleted) {
                elements.startButton.textContent = '重新开始';
            } else if (AppState.volumes.length > 0) {
                 elements.startButton.textContent = '继续';
            }
            elements.startButton.disabled = false;
            updateVolumeSelect();
        }
    }
    
    // V12.2: 新增解析函数 (保持不变)
    function parseContentAndStatus(fullResponse) {
        const startIndex = fullResponse.indexOf(TRACKING_START);
        const endIndex = fullResponse.indexOf(TRACKING_END);
        
        let content = fullResponse;
        let status = {};

        if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
            content = fullResponse.substring(0, startIndex).trim();
            let jsonString = fullResponse.substring(startIndex + TRACKING_START.length, endIndex).trim();
            
            jsonString = jsonString.replace(/```json|```/g, '').trim();
            try {
                if (jsonString) {
                    status = JSON.parse(jsonString);
                    if (typeof status !== 'object' || status === null) {
                        throw new Error('Parsed result is not a JSON object.');
                    }
                }
            } catch (e) {
                log(`✗ 状态追踪 JSON 解析失败，跳过本次状态更新。原始JSON片段: ${jsonString.substring(0, 50)}...`, 'error');
                status = {};
            }
        }
        return [content, status];
    }

    // --- FILE I/O AND TASK MANAGEMENT (V13.6 TXT 格式化) ---
    function formatChapterDetails() {
        let content = `## 小说章节细纲和创作指引\n\n`;
        let chapterCounter = 1;
        AppState.volumes.forEach((volume, i) => {
            content += `\n# 卷${i + 1}：${volume.title} (${AppState.volumes.length}卷)\n\n`;
            content += `【本卷地图/背景】：${volume.map}\n\n`;
            volume.chapterPrompts.forEach((chapter) => {
                content += `--- 第${chapterCounter}章：${chapter.title} ---\n`;
                content += `【创作指引】：${chapter.prompt}\n`;
                if (chapter.statusChange && Object.keys(chapter.statusChange).length > 0) {
                     content += `【本章带来的状态变化】：${JSON.stringify(chapter.statusChange)}\n`;
                }
                content += '\n';
                chapterCounter++;
            });
        });
        return content;
    }

    // V13.6 新增：构建最终 TXT 导出的内容 (包含设定信息)
    function buildFinalExportContent() {
        const titles = AppState.bookSettings.titles;
        const synopsis = AppState.bookSettings.synopsis;
        const protagonist = AppState.bookSettings.protagonist;

        let content = "";
        
        // 2. 格式化书名、简介、主角名 (匹配用户要求格式)
        if (titles && titles.length > 0) {
            content += "书名方案:\n";
            titles.forEach((title, index) => {
                content += `《${title}》\n`;
            });
            content += `主角名: ${protagonist}\n\n`;
        }

        if (synopsis) {
            content += "故事简介:\n";
            content += `"${synopsis}"\n\n`;
        }
        
        // 3. 添加正文部分
        content += buildFinalContentFromState();

        return content.trim();
    }
    
    // V13.6 调整：buildFinalContentFromState 仅用于构建章节内容
    function buildFinalContentFromState() { 
        let content = ''; 
        let chapterCounter = 1;
        
        AppState.volumes.forEach((volume, i) => { 
            const volumeTitle = `\n\n第${i + 1}卷: ${volume.title}\n\n`; // 卷名格式

            if (volume.chapterPrompts.some(c => c.generatedContent)) {
                 content += volumeTitle;
            }
            
            volume.chapterPrompts.forEach((chapter) => { 
                const finalContent = chapter.generatedContent;
                if (finalContent) { 
                    const title = `第${chapterCounter}章: ${chapter.title}`; // 章标题格式
                    content += `${title}\n\n${finalContent}\n\n`; // 正文和章节间留两行空行
                }
                chapterCounter++; 
            }); 
        }); 
        return content.trim(); 
    }
    
    function saveTask(alsoSaveTxt = false) { 
        const title = elements.workTitleInput.value.trim() || 'AI生成作品';

        if (!title && AppState.volumes.length === 0) { alert('没有可保存的任务内容！'); return; } 
        
        AppState.totalWordCount = elements.totalWordCountInput.value;
        AppState.inspiration = elements.creativeInspirationInput.value;
        
        const taskState = { 
            ...AppState, 
            workTitle: title, 
            selectedModel: elements.modelSelect.value, 
            isStreamEnabled: elements.streamToggle.checked, 
            outlinePrompt: elements.outlinePromptInput.value, 
            targetWordCount: elements.targetWordCount.value, 
            kbCache: AppState.kbCache,
            tokenUsage: AppState.tokenUsage // V13.7 保存 token 记录
        }; 
        const blob = new Blob([JSON.stringify(taskState, null, 2)], { type: 'application/json' }); 
        const a = document.createElement('a'), url = URL.createObjectURL(blob); 
        a.href = url; 
        a.download = `${title}_task.json`; 
        document.body.appendChild(a); 
        a.click(); 
        document.body.removeChild(a); 
        URL.revokeObjectURL(url); 
        log('任务已保存为 .json 文件。', 'success'); 
        
        if (alsoSaveTxt) { 
            const completedContent = buildFinalExportContent(); 
            const timestamp = new Date().toISOString().slice(0, 16).replace('T', '-').replace(/:/g, '-');
            if(completedContent) saveAsTxt(completedContent, `${title}_小说正文_${timestamp}.txt`); 
            
            if(AppState.fullOutline) saveAsTxt(AppState.fullOutline, `${title}_大纲_${timestamp}.txt`);
            if(AppState.knowledgeBase) saveAsTxt(AppState.knowledgeBase, `${title}_知识库_${timestamp}.txt`);
            if(AppState.volumes.length > 0) saveAsTxt(formatChapterDetails(), `${title}_章节细纲_${timestamp}.txt`);
        } 
    }
    
    function loadTask(event) { 
        const file = event.target.files[0]; 
        if (!file) return; 
        const reader = new FileReader(); 
        reader.onload = (e) => { 
            try { 
                const s = JSON.parse(e.target.result); 
                
                elements.workTitleInput.value = s.workTitle || 'AI生成作品'; 
                elements.modelSelect.value = s.selectedModel || 'deepseek-chat'; 
                elements.streamToggle.checked = s.isStreamEnabled !== false; 
                elements.outlinePromptInput.value = s.outlinePrompt || ''; 
                elements.targetWordCount.value = s.targetWordCount || '3000'; 
                
                elements.totalWordCountInput.value = s.totalWordCount || '1000000';
                elements.creativeInspirationInput.value = s.inspiration || '';

                AppState.mode = 'new-book'; 
                AppState.volumes = s.volumes || [];
                AppState.fullOutline = s.fullOutline || '';
                AppState.knowledgeBase = s.knowledgeBase || '';
                AppState.bookSettings = s.bookSettings || { titles: [], synopsis: '', protagonist: '主角姓名待定' };
                AppState.currentRunningStatus = s.currentRunningStatus || {};
                AppState.kbCache = s.kbCache || {}; 
                AppState.tokenUsage = s.tokenUsage || { total: 0, prompt: 0, completion: 0, estimatedCost: 0 };

                elements.reviewPanel.style.display = 'none';

                updateEstimate();

                // V13.7 恢复加载任务时的监控显示
                let initialTotalWords = 0;
                let chaptersCompletedAtStart = 0;
                let totalChaptersInList = 0;
                for(const volume of AppState.volumes) {
                    totalChaptersInList += volume.chapterPrompts.length;
                    for(const chapter of volume.chapterPrompts) {
                        if (chapter.generatedContent) {
                            initialTotalWords += chapter.generatedContent.length;
                            chaptersCompletedAtStart++;
                        }
                    }
                }
                elements.wordCountDisplay.textContent = `${initialTotalWords.toLocaleString()} 字`;
                elements.chapterProgressText.textContent = `${chaptersCompletedAtStart} / ${totalChaptersInList} 章`;
                elements.mainProgressBar.value = chaptersCompletedAtStart;
                
                if (AppState.volumes.length > 0) {
                    elements.startButton.disabled = false;
                    updateVolumeSelect();
                } else {
                     elements.startButton.disabled = true;
                }
                
                elements.startButton.textContent = '开始/继续'; 
                log('任务加载成功！', 'success'); 
                const completedCount = AppState.volumes.reduce((sum, v) => sum + v.chapterPrompts.filter(c => c.generatedContent).length, 0);
                if(completedCount > 0) log(`${completedCount} 个章节已完成，将从断点处继续。`, 'info'); 
            } catch (error) { 
                log(`加载任务失败: ${error.message}`, 'error'); 
            } 
        }; 
        reader.readAsText(file); 
        event.target.value = ''; 
    }

    // --- KEY VERIFICATION ---
    async function verifyKey(key, modelId) {
        const isDeepSeek = modelId.toLowerCase().includes('deepseek');
        const url = DEEPSEEK_API_URL;
        
        try {
            const messages = [{ role: 'user', content: 'test' }];
            const requestBody = { model: modelId, messages, temperature: 0.1, max_tokens: 1 };
                
            const response = await fetch(url, { 
                method: 'POST', 
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` }, 
                body: JSON.stringify(requestBody)
            });

            if (response.ok) {
                return { status: true, message: '验证成功' };
            } else {
                const errorData = await response.json();
                return { status: false, message: errorData.message || `HTTP Error: ${response.status}` };
            }
        } catch (error) {
            return { status: false, message: error.message || '网络连接错误' };
        }
    }

    async function verifyAndSaveKey() { 
        const mainKey = elements.apiKeyInput.value.trim(); 
        if (!mainKey) { alert('主力 API Key 不能为空！'); return; } 
        setKeyStatus('verifying'); 
        
        const result = await verifyKey(mainKey, elements.modelSelect.value);

        if (result.status) { 
            setKeyStatus('verified'); 
            localStorage.setItem('deepseek_api_key_verified', mainKey); 
            log(`主力 Key 验证成功！模型: ${elements.modelSelect.value}`, 'success'); 
        } else {
            setKeyStatus('invalid', `验证失败: ${result.message}`); 
            localStorage.removeItem('deepseek_api_key_verified'); 
            log(`主力 Key 验证失败: ${result.message}`, 'error'); 
        }
    }

    async function verifyAndSaveFormatKey() {
        const formatKey = elements.formatApiKeyInput.value.trim(); 
        if (!formatKey) { alert('Formatting API Key 不能为空！'); return; } 
        
        elements.formatKeyStatus.className = 'status-verifying';
        elements.formatKeyStatus.textContent = '验证中...';

        const result = await verifyKey(formatKey, elements.formatModelSelect.value);

        if (result.status) {
            elements.formatKeyStatus.className = 'status-verified';
            elements.formatKeyStatus.textContent = '✓ 已验证';
            log(`Formatting Key 验证成功！模型: ${elements.formatModelSelect.value}`, 'success');
        } else {
            elements.formatKeyStatus.className = 'status-invalid';
            elements.formatKeyStatus.textContent = `✗ ${result.message}`;
            log(`Formatting Key 验证失败: ${result.message}`, 'error');
        }
    }

    function setKeyStatus(status, message = '') { 
        elements.keyStatus.className = ''; 
        elements.mainControls.disabled = true; 
        switch(status) { 
            case 'verified': 
                elements.keyStatus.classList.add('status-verified'); 
                elements.keyStatus.textContent = '✓ 已验证'; 
                elements.mainControls.disabled = false; 
                elements.startButton.disabled = AppState.volumes.length === 0; 
                elements.generateSettingButton.disabled = false; 
                break; 
            case 'invalid': 
                elements.keyStatus.classList.add('status-invalid'); 
                elements.keyStatus.textContent = `✗ ${message || '无效的 Key'}`; 
                break; 
            case 'verifying': 
                elements.keyStatus.classList.add('status-verifying'); 
                elements.keyStatus.textContent = '验证中...'; 
                break; 
            default: 
                elements.keyStatus.classList.add('status-unverified'); 
                elements.keyStatus.textContent = '未验证'; 
                break; 
        } 
    }
    

    // --- EVENT LISTENERS ---
    document.addEventListener('DOMContentLoaded', () => { 
        const savedKey = localStorage.getItem('deepseek_api_key_verified'); 
        if (savedKey) { 
            elements.apiKeyInput.value = savedKey; 
            setKeyStatus('verified'); 
            log('已加载保存的 API Key。', 'info'); 
        } 
        updateEstimate(); 
        
        if (!elements.workTitleInput) {
            elements.workTitleInput = { value: 'AI生成作品', placeholder: '' };
        }
        
        document.getElementById('panel-ai').classList.add('active');

        // V13.7 初始化监控UI
        elements.wordCountDisplay.textContent = '0 字';
        elements.chapterProgressText.textContent = '0 / 0 章';
        elements.mainProgressBar.value = 0;

        // V15.4 最终修复：绑定所有事件
        elements.generateSettingButton.addEventListener('click', generateFullSetting); 
        elements.startButton.addEventListener('click', startGeneration);
        elements.confirmSettingButton.addEventListener('click', confirmSetting); 

        elements.apiKeyInput.addEventListener('input', () => { if (elements.apiKeyInput.value.trim() !== localStorage.getItem('deepseek_api_key_verified')) setKeyStatus('unverified'); });
        elements.verifyKeyButton.addEventListener('click', verifyAndSaveKey);

        elements.totalWordCountInput.addEventListener('input', updateEstimate);
        elements.targetWordCount.addEventListener('input', updateEstimate);

        elements.saveTaskButton.addEventListener('click', () => saveTask(true));
        elements.loadTaskButton.addEventListener('click', () => elements.loadTaskInput.click());
        elements.loadTaskInput.addEventListener('change', loadTask);
        elements.autosaveEnable.addEventListener('change', () => { elements.autosaveOptions.classList.toggle('fieldset-disabled', !elements.autosaveEnable.checked); });
    });
    
</script>

</body>
</html>